module.exports = {
  mode:"development",
  devtool:"source-map",
  devServer:{
    port:8000,
    open:true,
    openPage:"abc.html",//配置的是启动OPEN的情况下默认打开的"类"dist目录下的具体的文件
    index:"abc.html",
    proxy :{//服务器代理规则
      // "/api": "http://duyi.com" --此为直接代理的语法糖，正常的完整的赋值格式应当如下:
      "/api":{
        target:"http://duyi.com",
        changeOrigin:true, //允许修改请求url的同时修改请求报文(对象)中的host和origin属性
        stats:{
          module:false,
          colors:true 
        },
      }
    }
  }
}
 

//webpack开发服务器本质在启动之后监听的是配置文件(对象)以及插件所提供的资源是否发生改变，若发生改变则重新执行的是编译过程，而不包含
//初始化webpack对象的过程,故说明当配置文件的内容以及未被索引到的内容发生了修改并不会重执行编译过程，同时初始化webpack配置对象中带
//有webpack开发服务器的配置项


//对开发服务器的具体配置项进行解释：
//1、port：控制webpack开发服务器的启动端口号
//2、open：控制是否在启动服务后浏览器自动打开当前启动的IP以及端口(不包含路径内容)
//3、index：配置最初的url中的根路径结构，若设置了上述的abc.html则在访问http://localhost:8000的时候无法访问到webpack开发服务器的启动的经典的首页
//而只有http://localhost:8000/abc.html才能访问到首页内容，同时若配置的index值恰好未:"index.html"，则在直接访问http://localhost:8000的时候同样可以
//访问到开发服务器的首页，原因在于若根url中没有路径的情况下没有访问到目标的资源内容的时候会自动添加上index.html的路径作为二次查找的条件，
//故恰好和特殊情况下的index配置取值一致故能够访问到开发服务器首页
//4、proxy：控制的是服务器代理，其中规则的内容表示当当前开发服务器中的内容请求的url中包含/api则将url中的协议名、IP、端口号替换为：
//proxy对象的赋值，同时需要注意代理后若请求的IP和原先的IP不一致并不会导致跨域问题的存在，原因在于。。下方拓展介绍了;同时若请求的目标服务器
//硬性要求中存在着host和当前请求内容应当一致的要求，则需要设置代理的origin属性一同修改为目标服务器标准化的host(所谓的标准化指的是host中的内容被代理后的url中的内容所包含)
//否则只能通过跨域问题无法完成响应资源的获取
//5、stats：控制开发服务器启动状态下开发服务器启动的终端中的控制台输出的内容的样式以及内容，同时其中的module配置是否输出模块(chunk对应的各个asset是否映射输出)，colors
//用于控制控制台中区分度较大的关键字颜色.同时针对stats这个webpack.config.js独有的配置将该配置就算不放在开发服务器的配置(devServer)中放在和其并列的位置中
//在初始化webpack配置对象的时候会自动将其放置在开发服务器的配置(devServer)中


// 同时需要注意在当前使用了webpack-dev-server的基础上完成并且执行该指令完成打包的过程中由于整体需要使用上开发服务器相关的包内容(require("webpack_dev_server"))故在最终打包的资源
//中会存在着和开发服务器相关的modules，故打包的模块(chunks或者assets)中会存在众多的开发服务器相关被引入的模块代码



// 提示：先前学过的其它plugin拓展中也有stats这个拓展，完成打包(编译)后的内容输出结果的样式设计以及内容



//补充：当js中书写的请求中仅存在路径信息，则在向浏览器端发送请求的时候携带的协议名、IP、端口号的信息和当前文件被启动的服务的协议名、IP和端口一致(因为该请求的路径是相对于当前网站域名的)


// 拓展：
// 🔍 浏览器中的请求流程：
// 1、当你在 JS 中发起一个请求时（例如 fetch() 或 XMLHttpRequest），请求的过程实际上是由浏览器管理的。浏览器是请求的中转站，它会负责以下几步：
// 2、请求发送：JS 代码通过 fetch() 或其他方式发起网络请求。此时，浏览器会将该请求发送到指定的 URL。
// 3、同源策略检查：浏览器会检查该请求是否符合同源策略（即协议、域名、端口是否一致）。
// （1）如果是同源请求：浏览器会直接发送请求到目标服务器。
// （2）如果是跨域请求：浏览器会向目标服务器发送一个 OPTIONS 预检请求，确认服务器是否允许该跨域请求。如果服务器响应允许，才会真正发送请求。
// 4、响应处理：请求成功返回后，浏览器会将服务器的响应返回给 JS。此时，浏览器可能会对跨域请求进行 CORS 处理，允许访问或阻止访问。

// 🔄 代理的工作原理（Proxy）：
// 代理（比如 Webpack 的开发代理）是由开发服务器实现的，它并不受浏览器的同源策略限制。代理会“代替”浏览器向目标服务器发起请求。它的原理如下：
// 1、请求解析：当浏览器看到你在代码中发起的请求时（如 fetch('/api/endpoint')），它会将请求发送给本地开发服务器，因为该请求的路径是相对于当前网站域名的（即 localhost:3000/api/endpoint）。
// 2、代理匹配：开发服务器（如 Webpack Dev Server）会检查请求路径是否符合配置的代理规则。例如，/api 规则指示服务器将请求转发给目标服务器。
// 3、转发请求：如果请求符合代理规则，开发服务器会根据配置将请求转发到指定的目标服务器（如 https://real-api.com/api/endpoint）。
// 4、响应返回：目标服务器返回响应后，开发服务器将响应传递回浏览器。浏览器没有察觉到是“跨域请求”，因为请求本质上是发往开发服务器的，而不是直接发往跨域的目标服务器。