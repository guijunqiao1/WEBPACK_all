module.exports = {
  mode:"development",
  devtool:"source-map",
  module:{
    noParse:/jquery/ //需要注意的是此处的配置为不解析的模块(具体文件)，同时需要注意的是就算不进行解析，但是在编译结果中任然存在该模块的内容，
    //因为不解析的本质也就是不进行单纯的分析和替换依赖名称的操作，但是如果自身被其它文件依赖了，那么自身还是会被当作一个模块进行处理(也就是在
    //资源列表中是存在的，只是不存在编译流程中的依赖列表中了(本身起始也没有依赖，此时更是不进行分析和记录依赖了)，也就能够在编译结果中访问到了)
    
    //同时还需要注意的是当前配置项是先前的loader的rules的配置项的载体--也就可以反映module配置项控制的是在编译过程中的一系列工作的情况了
  }
}

//同时需要注意的是：若不解析的模块存在require的语句，则在编译流程中仍无法根据被webpack标记后的require(或者import)进行引入的依赖文件的
//进入，也就是说最终生成的assets列表的总对数会减少，同时生成的assets文件(output文件)中的当前终止的文件的内容中的import或者require是没被
//webpack转化的，同时反映了webpack对目标内容进行总的assets列表的获取的依据是依赖的名称替换后的索引的必要条件的存在，同时在最终的运行文件中
//进行assets文件中的依赖的同文件导航功能的实现同时也是利用了更名后的require(或者import)的语句的特性进行当前特殊引入功能的实现



//需要注意的是即使解析进行依赖模块的替换指的是import、require这种导入语句而不是导出语句，从而说明了webpack将导入语句替换为__webpack_require__(以require为例)这种形式
//之后进行依赖的引入就算依赖导出语句是原生的没替换的export...的语句，则在运行该打包(编译)文件的时候同样能够成功进行引入